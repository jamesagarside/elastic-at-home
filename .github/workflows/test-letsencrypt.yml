name: Test Let's Encrypt Deployment

on:
  # Manual trigger only - to avoid Let's Encrypt rate limits
  workflow_dispatch:
    inputs:
      stack_version:
        description: 'Elastic Stack version to test'
        required: false
        default: '9.2.2'
      test_domain:
        description: 'Base domain for testing (e.g., siem.example.com)'
        required: true
      use_staging:
        description: 'Use Let''s Encrypt staging (recommended for testing)'
        required: false
        default: 'true'
        type: boolean
      debug:
        description: 'Enable debug output'
        required: false
        default: 'false'
        type: boolean

  # Optional: scheduled weekly test
  schedule:
    # Run weekly on Sunday at 3am UTC
    - cron: '0 3 * * 0'

env:
  STACK_VERSION: ${{ github.event.inputs.stack_version || '9.2.2' }}
  # Default domain for scheduled runs - override via workflow_dispatch
  TEST_DOMAIN: ${{ github.event.inputs.test_domain || vars.TEST_DOMAIN }}

jobs:
  validate-inputs:
    name: Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      domain_valid: ${{ steps.validate.outputs.domain_valid }}

    steps:
      - name: Validate secrets and inputs
        id: validate
        run: |
          errors=0

          # Check for required secret
          if [[ -z "${{ secrets.CF_DNS_API_TOKEN }}" ]]; then
            echo "::error::Missing required secret: CF_DNS_API_TOKEN"
            errors=$((errors + 1))
          fi

          # Check for domain
          if [[ -z "${{ env.TEST_DOMAIN }}" ]]; then
            echo "::error::Missing required input: test_domain (or set TEST_DOMAIN repository variable)"
            errors=$((errors + 1))
          fi

          # Check for ACME email
          if [[ -z "${{ secrets.ACME_EMAIL }}" && -z "${{ vars.ACME_EMAIL }}" ]]; then
            echo "::warning::No ACME_EMAIL set, using default"
          fi

          if [[ $errors -gt 0 ]]; then
            echo "domain_valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "domain_valid=true" >> $GITHUB_OUTPUT
          echo "Configuration validated successfully"

  test-letsencrypt:
    name: Let's Encrypt Certificate Mode
    needs: validate-inputs
    if: needs.validate-inputs.outputs.domain_valid == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure domain variables
        id: domains
        run: |
          BASE_DOMAIN="${{ env.TEST_DOMAIN }}"

          # Generate subdomain names
          echo "kibana_domain=kibana.${BASE_DOMAIN}" >> $GITHUB_OUTPUT
          echo "es_domain=elasticsearch.${BASE_DOMAIN}" >> $GITHUB_OUTPUT
          echo "fleet_domain=fleet.${BASE_DOMAIN}" >> $GITHUB_OUTPUT
          echo "apm_domain=apm.${BASE_DOMAIN}" >> $GITHUB_OUTPUT
          echo "agent_domain=agent.${BASE_DOMAIN}" >> $GITHUB_OUTPUT
          echo "traefik_domain=proxy.${BASE_DOMAIN}" >> $GITHUB_OUTPUT

          echo "Domain configuration:"
          echo "  Kibana: kibana.${BASE_DOMAIN}"
          echo "  Elasticsearch: elasticsearch.${BASE_DOMAIN}"
          echo "  Fleet: fleet.${BASE_DOMAIN}"
          echo "  APM: apm.${BASE_DOMAIN}"
          echo "  Traefik: proxy.${BASE_DOMAIN}"

      - name: Create .env file
        run: |
          # Determine ACME server based on staging flag
          ACME_SERVER=""
          if [[ "${{ github.event.inputs.use_staging }}" == "true" ]]; then
            echo "Using Let's Encrypt STAGING server"
            ACME_SERVER="https://acme-staging-v02.api.letsencrypt.org/directory"
          else
            echo "Using Let's Encrypt PRODUCTION server"
          fi

          cat > .env << EOF
          # Certificate Mode: letsencrypt for publicly trusted certs
          CERT_RESOLVER=letsencrypt

          # ACME settings
          ACME_EMAIL=${{ secrets.ACME_EMAIL || vars.ACME_EMAIL || 'test@example.com' }}
          CF_DNS_API_TOKEN=${{ secrets.CF_DNS_API_TOKEN }}

          # Security credentials
          ELASTIC_PASSWORD=TestPassword123!
          KIBANA_PASSWORD=TestPassword123!
          APM_SECRET_TOKEN=TestAPMToken123!

          # Stack version
          STACK_VERSION=${{ env.STACK_VERSION }}

          # Cluster settings
          CLUSTER_NAME=test-cluster-le
          LICENSE=basic

          # Domain names
          KIBANA_DOMAIN_NAME=${{ steps.domains.outputs.kibana_domain }}
          ES_DOMAIN_NAME=${{ steps.domains.outputs.es_domain }}
          FLEET_DOMAIN_NAME=${{ steps.domains.outputs.fleet_domain }}
          APM_DOMAIN_NAME=${{ steps.domains.outputs.apm_domain }}
          AGENT_DOMAIN_NAME=${{ steps.domains.outputs.agent_domain }}
          TRAEFIK_DOMAIN_NAME=${{ steps.domains.outputs.traefik_domain }}

          # Port mappings (bind to all interfaces for external access)
          ES_PORT=0.0.0.0:9200
          KIBANA_PORT=0.0.0.0:5601
          FLEET_PORT=0.0.0.0:8220
          AGENT_PORT=0.0.0.0:5514

          # Allowed syslog IPs
          ALLOWED_SYSLOG_IPS=0.0.0.0/0

          # Memory limits (reduced for CI)
          KB_MEM_LIMIT=1073741824
          ES_MEM_LIMIT=2147483648
          FLEET_MEM_LIMIT=1073741824
          AGENT_MEM_LIMIT=1073741824

          # Kibana encryption keys
          KB_SECURITY_ENCRYPTIONKEY=fRDzAmciu0Sv3c0S8lKxJMrxJbEoEKG1
          KB_REPORTING_ENCRYPTIONKEY=Ih2qXq9iuXdiXg1jo4yXZV8gJWc6stzH
          KB_OBJECTS_ENCRYPTIONKEY=ny6tYXoI3lYrRcpgMSMQAkrSBen8dE9K
          EOF

      - name: Configure Traefik for staging (if enabled)
        if: github.event.inputs.use_staging == 'true'
        run: |
          # Modify traefik config to use staging server
          if [[ -f configurations/traefik/traefik-letsencrypt.yml ]]; then
            echo "Configuring Traefik for Let's Encrypt staging..."
            # Add caServer for staging
            sed -i 's|certificatesResolvers:|certificatesResolvers:\n    letsencrypt:\n      acme:\n        caServer: https://acme-staging-v02.api.letsencrypt.org/directory|' configurations/traefik/traefik-letsencrypt.yml || true
          fi

      - name: Increase vm.max_map_count for Elasticsearch
        run: |
          sudo sysctl -w vm.max_map_count=262144

      - name: Start Elastic Stack
        run: |
          echo "Starting Elastic Stack with Let's Encrypt certificates..."
          docker compose up -d
          echo "Stack started, waiting for services to initialize..."

      - name: Wait for Setup container to complete
        run: |
          echo "Waiting for setup container to complete..."
          timeout 300 bash -c '
            while true; do
              # Check if setup container has exited (not running)
              if ! docker compose ps setup --status running 2>/dev/null | grep -q setup; then
                # Container is not running, check exit code
                exit_code=$(docker inspect --format="{{.State.ExitCode}}" elastic-at-home-setup-1 2>/dev/null || echo "unknown")
                if [[ "$exit_code" == "0" ]]; then
                  echo "Setup completed successfully"
                  exit 0
                elif [[ "$exit_code" == "unknown" ]]; then
                  echo "Setup container not found yet, waiting..."
                else
                  echo "Setup failed with exit code $exit_code"
                  docker compose logs setup
                  exit 1
                fi
              else
                echo "Setup container still running..."
              fi
              sleep 10
            done
          '

      - name: Wait for certificate issuance
        run: |
          echo "Waiting for Let's Encrypt certificate issuance (this may take a few minutes)..."
          echo "Monitoring Traefik logs for certificate status..."

          timeout 600 bash -c '
            while true; do
              # Check for successful certificate
              if docker compose logs traefik 2>&1 | grep -q "Certificate obtained successfully"; then
                echo "Certificate obtained successfully!"
                exit 0
              fi

              # Check for ACME errors
              if docker compose logs traefik 2>&1 | grep -qE "(unable to obtain|ACME error|challenge failed)"; then
                echo "Certificate issuance failed!"
                docker compose logs traefik
                exit 1
              fi

              echo "Waiting for certificate... (checking every 30s)"
              sleep 30
            done
          '

      - name: Wait for Elasticsearch to be healthy
        run: |
          echo "Waiting for Elasticsearch to be healthy..."
          timeout 300 bash -c '
            while true; do
              if docker compose ps es01 --status healthy 2>/dev/null | grep -q es01; then
                echo "Elasticsearch is healthy"
                exit 0
              fi
              echo "Elasticsearch not healthy yet, waiting..."
              sleep 10
            done
          '

      - name: Wait for Kibana to be healthy
        run: |
          echo "Waiting for Kibana to be healthy..."
          timeout 300 bash -c '
            while true; do
              if docker compose ps kibana --status healthy 2>/dev/null | grep -q kibana; then
                echo "Kibana is healthy"
                exit 0
              fi
              echo "Kibana not healthy yet, waiting..."
              sleep 10
            done
          '

      - name: Wait for Fleet Server to be healthy
        run: |
          echo "Waiting for Fleet Server to be healthy..."
          timeout 300 bash -c '
            while true; do
              if docker compose ps fleet-server --status healthy 2>/dev/null | grep -q fleet-server; then
                echo "Fleet Server is healthy"
                exit 0
              fi
              echo "Fleet Server not healthy yet, waiting..."
              sleep 10
            done
          '

      - name: Wait for Agent to be running
        run: |
          echo "Waiting for Elastic Agent..."
          sleep 30

      - name: Show running containers
        run: |
          docker compose ps -a

      - name: Install test dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq openssl

      - name: Verify Let's Encrypt certificate
        run: |
          echo "Verifying Let's Encrypt certificate for Kibana..."

          KIBANA_DOMAIN="${{ steps.domains.outputs.kibana_domain }}"

          # Check certificate chain
          echo | openssl s_client -connect ${KIBANA_DOMAIN}:443 -servername ${KIBANA_DOMAIN} 2>/dev/null | \
            openssl x509 -noout -issuer -subject -dates

          # Verify it's from Let's Encrypt (or staging)
          ISSUER=$(echo | openssl s_client -connect ${KIBANA_DOMAIN}:443 -servername ${KIBANA_DOMAIN} 2>/dev/null | \
            openssl x509 -noout -issuer 2>/dev/null || echo "unknown")

          echo "Certificate issuer: $ISSUER"

          if echo "$ISSUER" | grep -qiE "(let's encrypt|letsencrypt|staging)"; then
            echo "Certificate is from Let's Encrypt"
          else
            echo "Warning: Certificate may not be from Let's Encrypt"
          fi

      - name: Run certificate tests
        id: cert_tests
        run: |
          export ELASTICSEARCH_URL="https://${{ steps.domains.outputs.es_domain }}"
          export KIBANA_URL="https://${{ steps.domains.outputs.kibana_domain }}"
          export FLEET_URL="https://${{ steps.domains.outputs.fleet_domain }}"
          export ELASTIC_PASSWORD="TestPassword123!"
          export CERT_RESOLVER="letsencrypt"
          # No CA_CERT needed for Let's Encrypt

          bash .github/scripts/test-stack.sh certificates
        continue-on-error: true

      - name: Run Elasticsearch tests
        id: es_tests
        run: |
          export ELASTICSEARCH_URL="https://${{ steps.domains.outputs.es_domain }}"
          export KIBANA_URL="https://${{ steps.domains.outputs.kibana_domain }}"
          export FLEET_URL="https://${{ steps.domains.outputs.fleet_domain }}"
          export ELASTIC_PASSWORD="TestPassword123!"
          export CERT_RESOLVER="letsencrypt"

          bash .github/scripts/test-stack.sh elasticsearch
        continue-on-error: true

      - name: Run Kibana tests
        id: kibana_tests
        run: |
          export ELASTICSEARCH_URL="https://${{ steps.domains.outputs.es_domain }}"
          export KIBANA_URL="https://${{ steps.domains.outputs.kibana_domain }}"
          export FLEET_URL="https://${{ steps.domains.outputs.fleet_domain }}"
          export ELASTIC_PASSWORD="TestPassword123!"
          export CERT_RESOLVER="letsencrypt"

          bash .github/scripts/test-stack.sh kibana
        continue-on-error: true

      - name: Run Fleet tests
        id: fleet_tests
        run: |
          export ELASTICSEARCH_URL="https://${{ steps.domains.outputs.es_domain }}"
          export KIBANA_URL="https://${{ steps.domains.outputs.kibana_domain }}"
          export FLEET_URL="https://${{ steps.domains.outputs.fleet_domain }}"
          export ELASTIC_PASSWORD="TestPassword123!"
          export CERT_RESOLVER="letsencrypt"

          bash .github/scripts/test-stack.sh fleet
        continue-on-error: true

      - name: Run Agent tests
        id: agent_tests
        run: |
          export ELASTICSEARCH_URL="https://${{ steps.domains.outputs.es_domain }}"
          export KIBANA_URL="https://${{ steps.domains.outputs.kibana_domain }}"
          export FLEET_URL="https://${{ steps.domains.outputs.fleet_domain }}"
          export ELASTIC_PASSWORD="TestPassword123!"
          export CERT_RESOLVER="letsencrypt"

          bash .github/scripts/test-stack.sh agent
        continue-on-error: true

      - name: Run full test suite
        id: full_tests
        run: |
          export ELASTICSEARCH_URL="https://${{ steps.domains.outputs.es_domain }}"
          export KIBANA_URL="https://${{ steps.domains.outputs.kibana_domain }}"
          export FLEET_URL="https://${{ steps.domains.outputs.fleet_domain }}"
          export ELASTIC_PASSWORD="TestPassword123!"
          export CERT_RESOLVER="letsencrypt"

          bash .github/scripts/test-stack.sh all

      - name: Test external HTTPS access
        run: |
          echo "Testing external HTTPS access to services..."

          # Test Kibana via HTTPS
          KIBANA_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            "https://${{ steps.domains.outputs.kibana_domain }}/api/status" \
            -u "elastic:TestPassword123!" 2>/dev/null || echo "000")

          echo "Kibana HTTPS status: $KIBANA_STATUS"

          if [[ "$KIBANA_STATUS" == "200" ]]; then
            echo "Kibana accessible via HTTPS with valid certificate"
          else
            echo "Warning: Kibana returned status $KIBANA_STATUS"
          fi

          # Test Fleet via HTTPS
          FLEET_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            "https://${{ steps.domains.outputs.fleet_domain }}/api/status" 2>/dev/null || echo "000")

          echo "Fleet HTTPS status: $FLEET_STATUS"

      - name: Collect logs on failure
        if: failure()
        run: |
          echo "=== Docker Compose Logs ==="
          docker compose logs --tail=100

          echo ""
          echo "=== Container Status ==="
          docker compose ps -a

          echo ""
          echo "=== Traefik Logs (ACME) ==="
          docker compose logs traefik --tail=100

          echo ""
          echo "=== Elasticsearch Logs ==="
          docker compose logs es01 --tail=50

          echo ""
          echo "=== Kibana Logs ==="
          docker compose logs kibana --tail=50

          echo ""
          echo "=== Fleet Server Logs ==="
          docker compose logs fleet-server --tail=50

      - name: Upload logs artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: docker-logs-letsencrypt
          path: |
            docker-compose-logs.txt
          retention-days: 7

      - name: Cleanup
        if: always()
        run: |
          docker compose down -v --remove-orphans
          docker system prune -f

  notify-failure:
    name: Notify on Failure
    needs: [test-letsencrypt]
    if: failure() && github.event_name == 'schedule'
    runs-on: ubuntu-latest

    steps:
      - name: Create issue on failure
        uses: actions/github-script@v7
        with:
          script: |
            const title = `Let's Encrypt Test Failed - ${new Date().toISOString().split('T')[0]}`;
            const body = `
            ## Scheduled Let's Encrypt Test Failed

            **Workflow Run:** [#${context.runNumber}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
            **Branch:** ${context.ref}
            **Triggered:** ${context.eventName}

            Please check the workflow logs for details.
            `;

            // Check if issue already exists
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: ['ci-failure', 'letsencrypt']
            });

            if (issues.data.length === 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['ci-failure', 'letsencrypt']
              });
            }
